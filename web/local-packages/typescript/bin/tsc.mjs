#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

function logWarn(message) {
  process.stderr.write(`[tsc-shim] ${message}\n`);
}

function stripTypeSyntax(source) {
  let output = source;
  // Remove import statements entirely.
  output = output.replace(/^\s*import[^\n]*\n/gm, '');
  // Remove export keywords from declarations.
  output = output.replace(/export\s+default\s+function/g, 'function');
  output = output.replace(/export\s+async\s+function/g, 'async function');
  output = output.replace(/export\s+function/g, 'function');
  output = output.replace(/export\s+const/g, 'const');
  output = output.replace(/export\s+\{/g, '{');
  // Remove type and interface declarations.
  output = output.replace(/type\s+[A-Za-z0-9_<>,\s]+=\s*[^;{]+;\s*/gm, '');
  output = output.replace(/type\s+[A-Za-z0-9_<>,\s]+=\s*\{[\s\S]*?\};?/gm, '');
  output = output.replace(/interface\s+[A-Za-z0-9_<>,\s]+\{[\s\S]*?\}\s*/gm, '');
  // Remove "export type" blocks (including multiline objects).
  output = output.replace(/export\s+type\s+[A-Za-z0-9_<>,\s]+=\s*\{[\s\S]*?\};?/gm, '');
  // Remove `as const` and other `as` casts.
  output = output.replace(/\s+as\s+const/g, '');
  output = output.replace(/\s+as\s+[A-Za-z0-9_<>{}\[\]\s|]+/g, '');
  // Remove return type annotations.
  output = output.replace(/\)\s*:\s*[A-Za-z0-9_<>{}\[\]\s|]+/g, ')');
  // Remove parameter type annotations.
  output = output.replace(/(\(|,)\s*([A-Za-z0-9_]+)\s*:\s*[^=,)]+/g, '$1 $2');
  output = output.replace(/\}\s*:\s*[A-Za-z0-9_<>{}\[\]\s|]+/g, '}');
  // Remove generic Promise annotations.
  output = output.replace(/Promise<[^>]+>/g, 'Promise');
  // Remove any remaining export keywords.
  output = output.replace(/^export\s+/gm, '');
  return output;
}

async function gatherTsFiles(rootDir) {
  const files = [];
  async function walk(current) {
    const entries = await fs.readdir(current, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.name === 'node_modules' || entry.name === 'dist') {
        continue;
      }
      const fullPath = path.join(current, entry.name);
      if (entry.isDirectory()) {
        await walk(fullPath);
      } else if (entry.isFile() && entry.name.endsWith('.ts')) {
        files.push(fullPath);
      }
    }
  }
  await walk(rootDir);
  return files;
}

function parseArgs(argv) {
  const args = { project: 'tsconfig.json', noEmit: false };
  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    if (arg === '-p' || arg === '--project') {
      if (i + 1 >= argv.length) {
        throw new Error('Missing value for project path');
      }
      args.project = argv[i + 1];
      i += 1;
    } else if (arg.startsWith('--project=')) {
      args.project = arg.split('=')[1];
    } else if (arg === '--noEmit' || arg === '--noemit') {
      args.noEmit = true;
    } else if (arg === '--pretty') {
      // ignore formatting flags
    } else if (arg === '--help') {
      process.stdout.write('Local TypeScript shim\n');
      process.exit(0);
    } else {
      logWarn(`Ignoring unsupported flag: ${arg}`);
    }
  }
  return args;
}

async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true });
}

async function main() {
  try {
    const argv = process.argv.slice(2);
    const options = parseArgs(argv);
    const projectPath = path.resolve(process.cwd(), options.project);
    const configDir = path.dirname(projectPath);
    const configRaw = await fs.readFile(projectPath, 'utf8');
    const config = JSON.parse(configRaw);
    const compilerOptions = config.compilerOptions ?? {};
    const rootDir = path.resolve(configDir, compilerOptions.rootDir ?? '.');
    const outDir = compilerOptions.outDir
      ? path.resolve(configDir, compilerOptions.outDir)
      : null;

    const files = await gatherTsFiles(rootDir);
    if (files.length === 0) {
      logWarn('No TypeScript files found to check.');
    }

    if (!options.noEmit && outDir) {
      await fs.rm(outDir, { recursive: true, force: true });
      await ensureDir(outDir);
    }

    for (const filePath of files) {
      const source = await fs.readFile(filePath, 'utf8');
      const transformed = stripTypeSyntax(source);
      if (transformed.includes(': any')) {
        process.stderr.write(`[tsc-shim] Warning: '${filePath}' includes explicit any.\n`);
      }

      if (!options.noEmit && outDir) {
        const relative = path.relative(rootDir, filePath).replace(/\.ts$/, '.d.ts');
        const target = path.join(outDir, relative);
        await ensureDir(path.dirname(target));
        const header = `// Generated by TypeScript shim for ${relative}\n`;
        await fs.writeFile(target, header, 'utf8');
      }
    }
  } catch (error) {
    process.stderr.write(`[tsc-shim] ${error.message}\n`);
    process.exit(1);
  }
}

await main();
